#!/bin/bash

# Script pour cr√©er les lanceurs dans le projet multi-apps-platform

set -e

# Couleurs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üöÄ CR√âATION DES SCRIPTS DE LANCEMENT DANS LE PROJET${NC}"
echo -e "${BLUE}=================================================${NC}"

# D√©terminer le r√©pertoire du projet
PROJECT_DIR="$(pwd)"
WORKSPACE_DIR="/Users/khalidksouri/global-multi-apps-workspace"

echo "üìÅ R√©pertoire du projet: $PROJECT_DIR"
echo "üìÅ Workspace des apps: $WORKSPACE_DIR"
echo ""

# 1. Cr√©er start-apps.sh dans le projet
echo -e "${YELLOW}‚ñ∂ Cr√©ation de start-apps.sh${NC}"
cat > "$PROJECT_DIR/start-apps.sh" << 'EOF'
#!/bin/bash

# Script de d√©marrage des applications depuis multi-apps-platform
# Usage: ./start-apps.sh

set -e

# Configuration
WORKSPACE_DIR="/Users/khalidksouri/global-multi-apps-workspace"
LOG_DIR="$WORKSPACE_DIR/logs"
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Cr√©er le dossier de logs
mkdir -p "$LOG_DIR"

# Couleurs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üöÄ D√âMARRAGE DU MULTI-APPS-PLATFORM${NC}"
echo -e "${BLUE}===================================${NC}"
echo ""
echo "üìÅ Projet: $PROJECT_DIR"
echo "üìÅ Workspace: $WORKSPACE_DIR"
echo "üìã Logs: $LOG_DIR"
echo ""

# Fonction de logging
log() {
    echo -e "${2:-$NC}[$1] $3${NC}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$1] $3" >> "$LOG_DIR/startup.log"
}

# Fonction pour v√©rifier les pr√©requis
check_prerequisites() {
    log "INFO" "$YELLOW" "V√©rification des pr√©requis..."
    
    # V√©rifier Node.js
    if ! command -v node &> /dev/null; then
        log "ERROR" "$RED" "Node.js n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier npm
    if ! command -v npm &> /dev/null; then
        log "ERROR" "$RED" "npm n'est pas install√©"
        exit 1
    fi
    
    # V√©rifier le workspace
    if [ ! -d "$WORKSPACE_DIR" ]; then
        log "ERROR" "$RED" "Workspace non trouv√©: $WORKSPACE_DIR"
        exit 1
    fi
    
    log "SUCCESS" "$GREEN" "Pr√©requis valid√©s"
}

# Fonction pour d√©marrer une application
start_app() {
    local app_name=$1
    local port=$2
    local command=$3
    local app_dir="$WORKSPACE_DIR/$app_name"
    
    if [ ! -d "$app_dir" ]; then
        log "ERROR" "$RED" "R√©pertoire $app_name non trouv√©: $app_dir"
        return 1
    fi
    
    log "INFO" "$YELLOW" "D√©marrage de $app_name sur le port $port..."
    
    cd "$app_dir"
    
    # V√©rifier si le port est libre
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
        log "WARNING" "$YELLOW" "Port $port d√©j√† utilis√© pour $app_name"
        
        # Proposer d'arr√™ter le processus existant
        echo -e "${YELLOW}Voulez-vous arr√™ter le processus existant sur le port $port ? (y/N)${NC}"
        read -r response
        if [[ "$response" =~ ^[Yy]$ ]]; then
            local pid=$(lsof -ti:$port)
            kill -9 $pid 2>/dev/null || true
            log "INFO" "$YELLOW" "Processus arr√™t√© sur le port $port"
            sleep 2
        else
            return 1
        fi
    fi
    
    # V√©rifier que package.json existe
    if [ ! -f "$app_dir/package.json" ]; then
        log "ERROR" "$RED" "package.json manquant pour $app_name"
        return 1
    fi
    
    # V√©rifier que node_modules existe
    if [ ! -d "$app_dir/node_modules" ]; then
        log "WARNING" "$YELLOW" "node_modules manquant pour $app_name, installation..."
        npm install
    fi
    
    # D√©marrer l'application en arri√®re-plan
    $command > "$LOG_DIR/${app_name}.log" 2>&1 &
    local pid=$!
    
    echo $pid > "$LOG_DIR/${app_name}.pid"
    
    # Attendre que l'application d√©marre
    log "INFO" "$YELLOW" "Attente du d√©marrage de $app_name (PID: $pid)..."
    sleep 8
    
    # V√©rifier si le processus est toujours actif
    if kill -0 $pid 2>/dev/null; then
        # V√©rifier si le port r√©pond
        local retries=0
        local max_retries=10
        
        while [ $retries -lt $max_retries ]; do
            if curl -s "http://localhost:$port" >/dev/null 2>&1; then
                log "SUCCESS" "$GREEN" "$app_name d√©marr√© avec succ√®s sur http://localhost:$port (PID: $pid)"
                return 0
            fi
            
            retries=$((retries + 1))
            sleep 2
        done
        
        log "WARNING" "$YELLOW" "$app_name processus actif mais port $port ne r√©pond pas encore"
        return 0
    else
        log "ERROR" "$RED" "$app_name a √©chou√© au d√©marrage"
        
        # Afficher les derni√®res lignes du log pour diagnostic
        if [ -f "$LOG_DIR/${app_name}.log" ]; then
            echo -e "${RED}Derni√®res lignes du log:${NC}"
            tail -n 5 "$LOG_DIR/${app_name}.log"
        fi
        
        return 1
    fi
}

# Fonction pour afficher le statut
show_status() {
    echo ""
    echo -e "${BLUE}üìä STATUT DES APPLICATIONS${NC}"
    echo -e "${BLUE}=========================${NC}"
    
    local apps=("math4kids:3001" "unitflip:3002" "budgetcron:3003" "ai4kids:3004" "multiai:3005")
    local running=0
    local total=5
    
    for app_port in "${apps[@]}"; do
        local app_name="${app_port%:*}"
        local port="${app_port#*:}"
        local pid_file="$LOG_DIR/${app_name}.pid"
        
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            if kill -0 "$pid" 2>/dev/null; then
                echo -e "  ‚úÖ $app_name: ${GREEN}Running${NC} (PID: $pid, Port: $port)"
                running=$((running + 1))
            else
                echo -e "  ‚ùå $app_name: ${RED}Stopped${NC} (Port: $port)"
            fi
        else
            echo -e "  ‚ùå $app_name: ${RED}Not started${NC} (Port: $port)"
        fi
    done
    
    echo ""
    echo -e "${BLUE}R√©sum√©: $running/$total applications en cours d'ex√©cution${NC}"
}

# Fonction principale
main() {
    # V√©rifications pr√©alables
    check_prerequisites
    
    echo ""
    echo -e "${YELLOW}üöÄ D√©marrage des applications...${NC}"
    echo ""
    
    # D√©marrage des applications
    start_app "math4kids" 3001 "npm start"
    sleep 3
    
    start_app "unitflip" 3002 "npm start"
    sleep 3
    
    start_app "budgetcron" 3003 "npm run serve"
    sleep 3
    
    start_app "ai4kids" 3004 "npm start"
    sleep 3
    
    start_app "multiai" 3005 "npm run dev"
    
    # Afficher le statut final
    show_status
    
    echo ""
    echo -e "${GREEN}üéâ D√âMARRAGE TERMIN√â!${NC}"
    echo ""
    echo -e "${YELLOW}üì± URLs des applications:${NC}"
    echo "  üìö Math4Kids:  http://localhost:3001"
    echo "  üîÑ UnitFlip:   http://localhost:3002"
    echo "  üí∞ BudgetCron: http://localhost:3003"
    echo "  ü§ñ AI4Kids:   http://localhost:3004"
    echo "  üß† MultiAI:    http://localhost:3005"
    echo ""
    echo -e "${YELLOW}üìã Gestion:${NC}"
    echo "  üìä Statut:     ./status-apps.sh"
    echo "  üìù Logs:       ls $LOG_DIR"
    echo "  üõë Arr√™t:      ./stop-apps.sh"
    echo ""
    
    # Retourner au r√©pertoire du projet
    cd "$PROJECT_DIR"
}

# Gestion des erreurs
trap 'echo -e "${RED}‚ùå Erreur d√©tect√©e${NC}"; cd "$PROJECT_DIR"; exit 1' ERR

# Lancement du script
main "$@"
EOF

chmod +x "$PROJECT_DIR/start-apps.sh"
echo -e "${GREEN}‚úÖ start-apps.sh cr√©√©${NC}"

# 2. Cr√©er stop-apps.sh dans le projet
echo -e "${YELLOW}‚ñ∂ Cr√©ation de stop-apps.sh${NC}"
cat > "$PROJECT_DIR/stop-apps.sh" << 'EOF'
#!/bin/bash

# Script d'arr√™t des applications depuis multi-apps-platform
# Usage: ./stop-apps.sh

set -e

# Configuration
WORKSPACE_DIR="/Users/khalidksouri/global-multi-apps-workspace"
LOG_DIR="$WORKSPACE_DIR/logs"
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Couleurs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üõë ARR√äT DU MULTI-APPS-PLATFORM${NC}"
echo -e "${BLUE}===============================${NC}"
echo ""

# Fonction pour arr√™ter une application
stop_app() {
    local app_name=$1
    local port=$2
    local pid_file="$LOG_DIR/${app_name}.pid"
    
    echo -e "${YELLOW}üõë Arr√™t de $app_name...${NC}"
    
    # M√©thode 1: Utiliser le fichier PID
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null
            echo -e "  ‚úÖ Processus arr√™t√© (PID: $pid)"
        else
            echo -e "  ‚ö†Ô∏è Processus d√©j√† arr√™t√©"
        fi
        rm -f "$pid_file"
    else
        echo -e "  ‚ö†Ô∏è Fichier PID non trouv√©"
    fi
    
    # M√©thode 2: Arr√™ter par port (backup)
    local port_pid=$(lsof -ti:$port 2>/dev/null || true)
    if [ -n "$port_pid" ]; then
        kill "$port_pid" 2>/dev/null || kill -9 "$port_pid" 2>/dev/null
        echo -e "  ‚úÖ Processus sur port $port arr√™t√© (PID: $port_pid)"
    fi
    
    echo -e "  ‚úÖ $app_name arr√™t√©"
}

# Fonction pour arr√™ter tous les processus Node.js du workspace
stop_all_node_processes() {
    echo -e "${YELLOW}üîç Recherche de processus Node.js dans le workspace...${NC}"
    
    # Trouver tous les processus Node.js li√©s au workspace
    local node_pids=$(ps aux | grep node | grep "$WORKSPACE_DIR" | grep -v grep | awk '{print $2}' || true)
    
    if [ -n "$node_pids" ]; then
        echo -e "${YELLOW}üìù Processus Node.js trouv√©s:${NC}"
        echo "$node_pids" | while read -r pid; do
            if [ -n "$pid" ]; then
                echo -e "  üõë Arr√™t du processus $pid"
                kill "$pid" 2>/dev/null || kill -9 "$pid" 2>/dev/null || true
            fi
        done
    else
        echo -e "  ‚ÑπÔ∏è Aucun processus Node.js trouv√©"
    fi
}

# Fonction pour nettoyer les fichiers temporaires
cleanup() {
    echo -e "${YELLOW}üßπ Nettoyage des fichiers temporaires...${NC}"
    
    # Nettoyer les fichiers PID
    rm -f "$LOG_DIR"/*.pid 2>/dev/null || true
    
    # Nettoyer les ports (m√©thode agressive)
    local ports=(3001 3002 3003 3004 3005)
    for port in "${ports[@]}"; do
        local pid=$(lsof -ti:$port 2>/dev/null || true)
        if [ -n "$pid" ]; then
            kill -9 "$pid" 2>/dev/null || true
            echo -e "  üõë Port $port lib√©r√©"
        fi
    done
    
    echo -e "${GREEN}‚úÖ Nettoyage termin√©${NC}"
}

# Fonction pour afficher le statut apr√®s arr√™t
show_final_status() {
    echo ""
    echo -e "${BLUE}üìä STATUT FINAL${NC}"
    echo -e "${BLUE}===============${NC}"
    
    local apps=("math4kids:3001" "unitflip:3002" "budgetcron:3003" "ai4kids:3004" "multiai:3005")
    local stopped=0
    local total=5
    
    for app_port in "${apps[@]}"; do
        local app_name="${app_port%:*}"
        local port="${app_port#*:}"
        
        if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
            echo -e "  ‚ö†Ô∏è $app_name: ${YELLOW}Encore actif${NC} (Port: $port)"
        else
            echo -e "  ‚úÖ $app_name: ${GREEN}Arr√™t√©${NC} (Port: $port)"
            stopped=$((stopped + 1))
        fi
    done
    
    echo ""
    if [ $stopped -eq $total ]; then
        echo -e "${GREEN}üéâ Toutes les applications sont arr√™t√©es ($stopped/$total)${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è $stopped/$total applications arr√™t√©es${NC}"
    fi
}

# Fonction principale
main() {
    echo "üìÅ Projet: $PROJECT_DIR"
    echo "üìÅ Workspace: $WORKSPACE_DIR"
    echo "üìã Logs: $LOG_DIR"
    echo ""
    
    # Arr√™t des applications par nom
    stop_app "math4kids" 3001
    stop_app "unitflip" 3002
    stop_app "budgetcron" 3003
    stop_app "ai4kids" 3004
    stop_app "multiai" 3005
    
    echo ""
    
    # Arr√™t de tous les processus Node.js restants
    stop_all_node_processes
    
    echo ""
    
    # Nettoyage final
    cleanup
    
    # Statut final
    show_final_status
    
    echo ""
    echo -e "${GREEN}üéâ ARR√äT TERMIN√â!${NC}"
    echo ""
    echo -e "${YELLOW}üìã Actions disponibles:${NC}"
    echo "  üöÄ Red√©marrer: ./start-apps.sh"
    echo "  üìä Statut:     ./status-apps.sh"
    echo "  üìù Logs:       ls $LOG_DIR"
    echo ""
    
    # Retourner au r√©pertoire du projet
    cd "$PROJECT_DIR"
}

# Gestion des erreurs
trap 'echo -e "${RED}‚ùå Erreur lors de l arr√™t${NC}"; cd "$PROJECT_DIR"; exit 1' ERR

# Lancement du script
main "$@"
EOF

chmod +x "$PROJECT_DIR/stop-apps.sh"
echo -e "${GREEN}‚úÖ stop-apps.sh cr√©√©${NC}"

# 3. Cr√©er status-apps.sh dans le projet
echo -e "${YELLOW}‚ñ∂ Cr√©ation de status-apps.sh${NC}"
cat > "$PROJECT_DIR/status-apps.sh" << 'EOF'
#!/bin/bash

# Script de statut des applications depuis multi-apps-platform
# Usage: ./status-apps.sh

set -e

# Configuration
WORKSPACE_DIR="/Users/khalidksouri/global-multi-apps-workspace"
LOG_DIR="$WORKSPACE_DIR/logs"
PROJECT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Couleurs
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}üìä STATUT DU MULTI-APPS-PLATFORM${NC}"
echo -e "${BLUE}=================================${NC}"
echo ""

# Fonction pour v√©rifier le statut d'une application
check_app_status() {
    local app_name=$1
    local port=$2
    local pid_file="$LOG_DIR/${app_name}.pid"
    local app_dir="$WORKSPACE_DIR/$app_name"
    
    echo -e "${YELLOW}üì± $app_name (Port: $port)${NC}"
    
    # V√©rifier le r√©pertoire
    if [ ! -d "$app_dir" ]; then
        echo -e "  ‚ùå R√©pertoire: ${RED}Non trouv√©${NC}"
        return 1
    else
        echo -e "  ‚úÖ R√©pertoire: ${GREEN}$app_dir${NC}"
    fi
    
    # V√©rifier le processus
    if [ -f "$pid_file" ]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            echo -e "  ‚úÖ Processus: ${GREEN}Actif (PID: $pid)${NC}"
        else
            echo -e "  ‚ùå Processus: ${RED}Arr√™t√© (PID obsol√®te: $pid)${NC}"
            rm -f "$pid_file"
        fi
    else
        echo -e "  ‚ùå Processus: ${RED}Non d√©marr√©${NC}"
    fi
    
    # V√©rifier le port
    if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
        local port_pid=$(lsof -ti:$port)
        echo -e "  ‚úÖ Port $port: ${GREEN}Utilis√© (PID: $port_pid)${NC}"
        
        # Test de connectivit√© HTTP
        if curl -s --max-time 5 "http://localhost:$port" >/dev/null 2>&1; then
            echo -e "  ‚úÖ HTTP: ${GREEN}R√©pond${NC} - http://localhost:$port"
        else
            echo -e "  ‚ö†Ô∏è HTTP: ${YELLOW}Port ouvert mais ne r√©pond pas${NC}"
        fi
    else
        echo -e "  ‚ùå Port $port: ${RED}Libre${NC}"
    fi
    
    # V√©rifier les d√©pendances
    if [ -f "$app_dir/package.json" ]; then
        echo -e "  ‚úÖ Package.json: ${GREEN}Pr√©sent${NC}"
        if [ -d "$app_dir/node_modules" ]; then
            echo -e "  ‚úÖ Node_modules: ${GREEN}Install√©${NC}"
        else
            echo -e "  ‚ö†Ô∏è Node_modules: ${YELLOW}Manquant${NC}"
        fi
    else
        echo -e "  ‚ùå Package.json: ${RED}Manquant${NC}"
    fi
    
    # V√©rifier les logs r√©cents
    local log_file="$LOG_DIR/${app_name}.log"
    if [ -f "$log_file" ]; then
        local log_size=$(du -h "$log_file" | cut -f1)
        local last_modified=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$log_file" 2>/dev/null || echo "Inconnu")
        echo -e "  üìù Log: ${GREEN}$log_size${NC} (Modifi√©: $last_modified)"
        
        # V√©rifier s'il y a des erreurs r√©centes
        local recent_errors=$(tail -n 20 "$log_file" 2>/dev/null | grep -i "error\|failed\|exception" | wc -l | tr -d ' ')
        if [ "$recent_errors" -gt 0 ]; then
            echo -e "  ‚ö†Ô∏è Erreurs r√©centes: ${YELLOW}$recent_errors${NC}"
        fi
    else
        echo -e "  ‚ùå Log: ${RED}Aucun${NC}"
    fi
    
    echo ""
}

# Fonction pour afficher le r√©sum√© global
show_global_summary() {
    echo -e "${BLUE}üìã R√âSUM√â GLOBAL${NC}"
    echo -e "${BLUE}===============${NC}"
    
    local apps=("math4kids:3001" "unitflip:3002" "budgetcron:3003" "ai4kids:3004" "multiai:3005")
    local running=0
    local total=5
    local ports_used=0
    
    for app_port in "${apps[@]}"; do
        local app_name="${app_port%:*}"
        local port="${app_port#*:}"
        local pid_file="$LOG_DIR/${app_name}.pid"
        
        # Compter les applications en cours
        if [ -f "$pid_file" ]; then
            local pid=$(cat "$pid_file")
            if kill -0 "$pid" 2>/dev/null; then
                running=$((running + 1))
            fi
        fi
        
        # Compter les ports utilis√©s
        if lsof -Pi :$port -sTCP:LISTEN -t >/dev/null 2>&1; then
            ports_used=$((ports_used + 1))
        fi
    done
    
    echo -e "üöÄ Applications actives: ${GREEN}$running/$total${NC}"
    echo -e "üåê Ports utilis√©s: ${GREEN}$ports_used/5${NC}"
    
    # V√©rifier l'utilisation du syst√®me
    echo -e "üíæ Utilisation m√©moire Node.js:"
    ps aux | grep node | grep -v grep | awk '{print "  " $2 ": " $4"% - " $11}' || echo "  Aucun processus Node.js"
    
    echo -e "üìä Espace disque (logs):"
    if [ -d "$LOG_DIR" ]; then
        local log_size=$(du -sh "$LOG_DIR" 2>/dev/null | cut -f1 || echo "0")
        echo -e "  üìù Logs: ${GREEN}$log_size${NC}"
    fi
    
    echo ""
    
    # Recommandations
    if [ $running -eq $total ]; then
        echo -e "${GREEN}üéâ Toutes les applications fonctionnent correctement!${NC}"
    elif [ $running -eq 0 ]; then
        echo -e "${YELLOW}üí° Aucune application en cours. Lancez: ./start-apps.sh${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è Certaines applications ne fonctionnent pas.${NC}"
        echo -e "${YELLOW}üí° Actions sugg√©r√©es:${NC}"
        echo -e "  üîÑ Red√©marrer toutes: ./stop-apps.sh && ./start-apps.sh"
        echo -e "  üìù V√©rifier les logs: ls $LOG_DIR"
    fi
}

# Fonction principale
main() {
    echo "üìÅ Projet: $PROJECT_DIR"
    echo "üìÅ Workspace: $WORKSPACE_DIR"
    echo "üìã Logs: $LOG_DIR"
    echo ""
    
    # V√©rifier chaque application
    check_app_status "math4kids" 3001
    check_app_status "unitflip" 3002
    check_app_status "budgetcron" 3003
    check_app_status "ai4kids" 3004
    check_app_status "multiai" 3005
    
    # Afficher le r√©sum√©
    show_global_summary
    
    echo -e "${YELLOW}üìã Actions disponibles:${NC}"
    echo "  üöÄ D√©marrer: ./start-apps.sh"
    echo "  üõë Arr√™ter:  ./stop-apps.sh"
    echo "  üìä Statut:   ./status-apps.sh"
    echo "  üìù Logs:     ls $LOG_DIR"
    echo ""
}

# Lancement du script
main "$@"
EOF

chmod +x "$PROJECT_DIR/status-apps.sh"
echo -e "${GREEN}‚úÖ status-apps.sh cr√©√©${NC}"

# 4. Cr√©er un README pour les scripts
echo -e "${YELLOW}‚ñ∂ Cr√©ation du README${NC}"
cat > "$PROJECT_DIR/LAUNCHER_README.md" << 'EOF'
# üöÄ Scripts de Gestion Multi-Apps Platform

## üìã Scripts disponibles

### üöÄ `./start-apps.sh`
D√©marre toutes les applications du multi-apps-platform
- V√©rifie les pr√©requis (Node.js, npm, workspace)
- D√©marre les 5 applications sur leurs ports respectifs
- G√®re les conflits de ports
- Affiche les URLs d'acc√®s

### üõë `./stop-apps.sh`
Arr√™te toutes les applications en cours
- Arr√™t propre via fichiers PID
- Nettoyage des ports occup√©s
- Suppression des fichiers temporaires
- V√©rification de l'arr√™t complet

### üìä `./status-apps.sh`
Affiche le statut d√©taill√© de toutes les applications
- √âtat des processus
- Utilisation des ports
- Test de connectivit√© HTTP
- V√©rification des d√©pendances
- Analyse des logs

## üåê Applications et Ports

| Application | Port | URL | Technology |
|-------------|------|-----|------------|
| Math4Kids   | 3001 | http://localhost:3001 | React + TypeScript |
| UnitFlip    | 3002 | http://localhost:3002 | React + TypeScript |
| BudgetCron  | 3003 | http://localhost:3003 | Vue.js + TypeScript |
| AI4Kids     | 3004 | http://localhost:3004 | React + TypeScript |
| MultiAI     | 3005 | http://localhost:3005 | Next.js + TypeScript |

## üìù Logs et Diagnostic

### Localisation des logs
```bash
/Users/khalidksouri/global-multi-apps-workspace/logs/
‚îú‚îÄ‚îÄ startup.log          # Log global de d√©marrage
‚îú‚îÄ‚îÄ math4kids.log        # Logs de Math4Kids
‚îú‚îÄ‚îÄ unitflip.log         # Logs de UnitFlip
‚îú‚îÄ‚îÄ budgetcron.log       # Logs de BudgetCron
‚îú‚îÄ‚îÄ ai4kids.log          # Logs de AI4Kids
‚îú‚îÄ‚îÄ multiai.log          # Logs de MultiAI
‚îú‚îÄ‚îÄ math4kids.pid        # PID de Math4Kids
‚îú‚îÄ‚îÄ unitflip.pid         # PID de UnitFlip
‚îú‚îÄ‚îÄ budgetcron.pid       # PID de BudgetCron
‚îú‚îÄ‚îÄ ai4kids.pid          # PID de AI4Kids
‚îî‚îÄ‚îÄ multiai.pid          # PID de MultiAI
```

### Diagnostic des probl√®mes
```bash
# Voir les logs en temps r√©el
tail -f /Users/khalidksouri/global-multi-apps-workspace/logs/math4kids.log

# V√©rifier tous les logs d'erreurs
grep -i error /Users/khalidksouri/global-multi-apps-workspace/logs/*.log

# Voir les processus Node.js actifs
ps aux | grep node

# V√©rifier les ports utilis√©s
lsof -i :3001-3005
```

## üîß R√©solution de Probl√®mes

### Port d√©j√† utilis√©
```bash
# Identifier le processus sur un port
lsof -ti:3001

# Arr√™ter le processus
kill -9 $(lsof -ti:3001)
```

### Application ne d√©marre pas
```bash
# V√©rifier les d√©pendances
cd /Users/khalidksouri/global-multi-apps-workspace/math4kids
npm install

# Tester le d√©marrage manuel
npm start
```

### Nettoyage complet
```bash
# Arr√™t brutal de tous les processus
./stop-apps.sh

# Nettoyage des ports
for port in 3001 3002 3003 3004 3005; do
  kill -9 $(lsof -ti:$port) 2>/dev/null || true
done

# Red√©marrage propre
./start-apps.sh
```

## üìö Workflow Recommand√©

### D√©veloppement quotidien
```bash
# 1. V√©rifier le statut
./status-apps.sh

# 2. D√©marrer si n√©cessaire
./start-apps.sh

# 3. D√©velopper...

# 4. Arr√™ter en fin de journ√©e
./stop-apps.sh
```

### En cas de probl√®me
```bash
# 1. Statut d√©taill√©
./status-apps.sh

# 2. Arr√™t complet
./stop-apps.sh

# 3. V√©rification des logs
ls -la /Users/khalidksouri/global-multi-apps-workspace/logs/

# 4. Red√©marrage
./start-apps.sh
```

## ‚ö° Tips & Astuces

### Raccourcis utiles
```bash
# Alias recommand√©s pour ~/.zshrc ou ~/.bashrc
alias mstart='./start-apps.sh'
alias mstop='./stop-apps.sh'
alias mstatus='./status-apps.sh'

# Variables d'environnement utiles
export MULTI_APPS_WORKSPACE="/Users/khalidksouri/global-multi-apps-workspace"
export MULTI_APPS_LOGS="$MULTI_APPS_WORKSPACE/logs"
```

### Surveillance automatique
```bash
# Surveiller tous les logs
watch -n 2 './status-apps.sh | tail -n 20'

# Alerte si une app s'arr√™te
while true; do
  if ! ./status-apps.sh | grep -q "5/5"; then
    echo "‚ö†Ô∏è Une application s'est arr√™t√©e!"
  fi
  sleep 30
done
```

## üÜò Support

En cas de probl√®me persistant :
1. V√©rifiez les logs dans `/Users/khalidksouri/global-multi-apps-workspace/logs/`
2. Ex√©cutez `./status-apps.sh` pour un diagnostic complet
3. Consultez la documentation des frameworks (React, Vue.js, Next.js)
4. V√©rifiez que Node.js et npm sont √† jour

---
*Derni√®re mise √† jour: $(date)*
EOF

echo -e "${GREEN}‚úÖ LAUNCHER_README.md cr√©√©${NC}"

echo ""
echo -e "${GREEN}üéâ SCRIPTS DE LANCEMENT CR√â√âS AVEC SUCC√àS!${NC}"
echo ""
echo -e "${YELLOW}üìã Scripts disponibles dans le projet:${NC}"
echo "  üöÄ ./start-apps.sh   - D√©marrer toutes les applications"
echo "  üõë ./stop-apps.sh    - Arr√™ter toutes les applications"
echo "  üìä ./status-apps.sh  - V√©rifier le statut des applications"
echo "  üìö LAUNCHER_README.md - Documentation compl√®te"
echo ""
echo -e "${YELLOW}üåê URLs d'acc√®s apr√®s d√©marrage:${NC}"
echo "  üìö Math4Kids:  http://localhost:3001"
echo "  üîÑ UnitFlip:   http://localhost:3002" 
echo "  üí∞ BudgetCron: http://localhost:3003"
echo "  ü§ñ AI4Kids:   http://localhost:3004"
echo "  üß† MultiAI:    http://localhost:3005"
echo ""
echo -e "${BLUE}üí° Pour commencer:${NC}"
echo "  ./start-apps.sh"